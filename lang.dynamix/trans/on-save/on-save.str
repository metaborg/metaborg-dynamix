module on-save

imports  
  signatures/Dynamix-sig
  
  nabl2/runtime/analysis/constraint-compat
  nabl2/api
  nabl2/runtime
  
  codegen/dnx-common
  external

rules
  dnx-on-save:
    (_, _, ast@Module(name, _, _, _, _, _), path, project-path) -> (full_name, result)
    with
      filename := $[src-gen/dynamix/[name].dnxc]
    ; full_name := $[[project-path]/[filename]]
    ; result   := <compile-dnx-spec> ast
    ; dnx-log(|"INFO", $<Writing compiled Dynamix spec to '<filename>'>)
    
rules      
  compile-dnx-spec: Module(_,imports,_, Defs(types), Defs(defs), header) -> out 
    with
      // TODO: Check if this path works on Windows
      map := <new-hashtable>;
      <map(make-normDef(|map))> defs;
      grouped_defs := <hashtable-getlist; map( (\ (name, cases) -> DefGroup(name, <reverse> cases) \) )> map;
      out := <strip-annos> NormModule(imports, <make-header> header, <resolve-binds-all> grouped_defs)
      
  resolve-binds-all: term -> <topdown(try(resolve-binds))> term
  resolve-binds: bind@DNX_Bind(var, val) -> DNX_BindExp(var, val)
    where
      a    := <nabl2-get-ast-analysis> var;
      occ  := <nabl2-mk-occurrence(|"Var")> var;
      type := <nabl2-get-type(|a)> occ;
      <equal> ("ExpT", <get-constructor> type)
  
  make-header: h@DNX_Header(a, b, c) -> h
    where
      <gt> (<length> a, 0);
      <gt> (<length> b, 0);
      <gt> (<length> c, 0)
  make-header: _ -> None()
      
  make-normDef(|ht): d@Def(name, param, args, Block(body)) -> d
    where
      defcase := DefCase(args, param, body);
      cname := <strip-annos> name;
      <hashtable-push(|cname, defcase)> ht
   
  