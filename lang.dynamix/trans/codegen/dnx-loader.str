module dnx-loader

imports
  signatures/Dynamix-sig
  codegen/dnx-common
  libspoofax/core/language
  
    
rules
  // Load the currently active Dynamix specification
  // Returns an optional with None() if no spec could be loaded
  dnx-load-compiled-spec: _ -> Some(term)
    where
      main_module_name := "dynamic-semantics";
      modules := <dnx-load-compiled-modules>;	// Get all modules
      // Make sure there is at least a main module
      <lookup'> (main_module_name, modules)
    with
      // Start with the main module and recursively load all imported modules as well
      (_, header, defs) := <load-module-recursively(|[])> main_module_name;
      // Combine all the loaded modules into a single one
      term := NormModule(main_module_name, header, <dnx-group-defs> defs) 
  
  // Loading failed
  dnx-load-compiled-spec: _ -> None()
    where
     <debug(!"[Dynamix] ")> "Module 'dynamic-semantics' not found"

rules
  dnx-load-compiled-modules: _ -> filepaths
    with
      // Get the src-gen folder of the current language
      [(_, _, _, lang_root) | _] := <language-components>;
      path := $[[lang_root]/src-gen/dynamix/];
      
      // Get all the compiled Dynamix files from that folder
      filepaths := <readdir; filter(string-ends-with(|".dnxc")); map( (\fname -> (<remove-extension> fname, $[[path][fname]]) \) )> path;
      // Load and store all the modules
      <map(load-module-from-file; store-module)> filepaths
      
  load-module-from-file: (fname, filepath) -> (fname, mod)
    where
      mod := <ReadFromFile> filepath
      
  load-module-recursively(|map): name -> (newer_map, merged_header, merged_defs)
    where
      <not(in-map(|map))> name
    with
      (imports, header, defs) := <dnx-get-module-by-name> name;
      map2 := [name | map];
      to_import := <filter(not(in-map(|map)))> imports;
      
      (newer_map, new_header, new_defs) := <foldl(load-module-fold)> (to_import, (map2, None(), []));
      merged_header := <merge-header> (header, new_header);
      merged_defs := <concat> [defs, new_defs]
      
  load-module-recursively(|map): name -> (map, None(), [])
  
  in-map(|map): key -> key where <elem> (key, map) 
  
  load-module-fold: (name, (map, header, defs)) -> (map2, <merge-header> (new_header, header), <concat> [new_defs, defs])
    with
      (map2, new_header, new_defs) := <load-module-recursively(|map)> name

  store-module: (name, NormModule(imports, header, defs)) -> name
    where
      rules( dnx-get-module-by-name: name -> (imports, header, defs) )
      
      
  merge-header: (None(), e) -> e
  merge-header: (h@DNX_Header(_, _, _), None()) -> h
  merge-header: (h1@DNX_Header(_, _, _), h2@DNX_Header(_, _, _)) -> <debug(!"[Dynamix] "); fail> "Cannot merge two headers" 
  
  dnx-group-defs: defs -> out
    where
      out := <foldl(dnx-group-defs-fold); map( (\ (_, val) -> val \) )> (defs, [])
  
  dnx-group-defs-fold: (DefGroup(name, cases), map) -> new_map
    where
      DefGroup(_, other_cases) := <lookup'> (name, map)
    with
      new_map := <update-map> (map, name, DefGroup(name, <concat> [cases, other_cases]))
      
  dnx-group-defs-fold: (DefGroup(name, cases), map) -> [(name, DefGroup(name, cases))| map]
      