module dnx-instruction

imports
  signatures/Dynamix-sig
  codegen/dnx-common
  fvm-common
  
  codegen/fvm-primitive
  codegen/dnx-expression
  
rules
  dnx-compile-body(|_, _): MatchError(error) -> ([], MatchError(error))
  dnx-compile-body(|properties, blockslocks): (binds, param_binds, body) -> out
    with
      label_map := <filter(?DNX_Label(_)); map( (\ DNX_Label(name) -> (name, <newname; dnx-primitive-autolabel> name) \) )> body;
      body_with_labels := <topdown(try( (\ DNX_Label(name) -> <lookup'> (name, label_map) \) ))> body;
      out := <dnx-compile-instr(|binds, param_binds, properties, blockslocks)> (body_with_labels, [], None())
  
rules
  dnx-compile-instr(|b, p, prop, blocks): ([], instr, exp) -> (instr, exp)
  
  dnx-compile-instr(|b, p, prop, blocks): ([DNX_Exp(exp) | t], instrs, None()) -> out
    with
      (r_instr, r_exp) := <dnx-compile-exp(|b, p, prop, blocks)> exp;
      out := <dnx-compile-instr(|b, p, prop, blocks)> (t, <conc> (instrs, r_instr), r_exp)
      
  dnx-compile-instr(|b, p, prop, blocks): ([DNX_Return(exp) | t], instrs, None()) -> out
    with
      (r_instr, r_exp) := <dnx-compile-exp(|b, p, prop, blocks)> exp;
      out := <dnx-compile-instr(|b, p, prop, blocks)> (t, <conc> (instrs, r_instr), r_exp)
      
  dnx-compile-instr(|b, p, prop, blocks): ([DNX_BindExp(var, val) | t], instrs, None() ) -> out
    where
      dnx_var := <lookup'> (var, b)	// Already bound
    with
      (r_instr, r_exp) := <dnx-compile-exp(|b, p, prop, blocks)> val;
      (a_instr, None()) := <dnx-primitive-assign> (dnx_var, r_exp);
      out := <dnx-compile-instr(|b, p, prop, blocks)> (t, <conc> (instrs, r_instr, a_instr), None())
      
  dnx-compile-instr(|b, p, prop, blocks): ([DNX_BindExp(var, val) | t], instrs, None() ) -> out
    with
      (r_instr, r_exp) := <dnx-compile-exp(|b, p, prop, blocks)> val;
      new_var := <newname; dnx-primitive-autovar> var;
      (a_instr, None()) := <dnx-primitive-assign> (new_var, r_exp);
      newbind := (var, new_var);
      out := <dnx-compile-instr(|[newbind|b], p, prop, blocks)> (t, <conc> (instrs, r_instr, a_instr), None())
      
  dnx-compile-instr(|b, p, prop, blocks): ([DNX_Bind(var, val) | t], instrs, None() ) -> out
    where
      <lookup'> (var, b)	// Already bound
    with
      (_, res) := <dnx-compile-exp(|b, p, prop, blocks)> val;
      b' := <update-map> (b, var, res); // Update the bound value
      out := <dnx-compile-instr(|b', p, prop, blocks)> (t, instrs, None())
      
  dnx-compile-instr(|b, p, prop, blocks): ([DNX_Bind(var, val) | t], instrs, None() ) -> out
    with
      (_, res) := <dnx-compile-exp(|b, p, prop, blocks)> val;
      var_name := <newname> var;
      newbind := (var, res);
      out := <dnx-compile-instr(|[newbind|b], p, prop, blocks)> (t, instrs, None())
      
  dnx-compile-instr(|b, p, prop, blocks): ([label | t], instrs, None()) -> out
    where
      <dnx-primitive-is-label> label
    with
      out := <dnx-compile-instr(|b, p, prop, blocks)> (t, <conc> (instrs, [label]), None())
  
  dnx-compile-instr(|b, p, prop, blocks): ([e | _], _, _) -> <debug(!"[Dynamix] "); fail> $[Undefined instr: [<write-to-string> e]] 
  