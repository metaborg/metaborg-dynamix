module dnx-expression

imports
  signatures/Dynamix-sig
  
  codegen/dnx-common
  codegen/dnx-compile
  codegen/fvm-primitive
  
  fvm-common

  
rules
  dnx-compile-exp(|b, p): exp -> out
    where
      bound_exp := <dnx-bind-args(|b)> exp;
      out := <dnx-compile-exp(|p)> bound_exp
      
  dnx-bind-args(|binds): term -> <topdown(try(dnx-bind-args-(|binds)))> term
  dnx-bind-args-(|binds): DNX_Var(name) -> res
    with
      res := <getfirst((\(key, val) -> val where <equal> (name, key)\))> binds
      
rules
  dnx-compile-exp(|p): DNX_Call(c_name, c_param, c_args) -> (instr, out_exp)
    with
      s_name := <lookup-or-default(|c_name)> (c_name, p);
      s_param := <map((\ param -> <lookup-or-default(|param)> (param, p) \))> c_param;
      (arg_instrs, args_exp) := <extract-instructions> <map(dnx-compile-exp(|p))> c_args;
      (out_instr, out_exp) := <dnx-call(| s_name, s_param)> args_exp;
      instr := <conc> (arg_instrs, out_instr)
   
  lookup-or-default(|default): (name, map) -> res
    where
      res := <getfirst((\(key, val) -> val where <equal> (name, key)\))> map
  lookup-or-default(|default): _ -> default
  
  extract-instructions: [] -> ([], [])
  
  extract-instructions: [(instr, exp) | t] -> (<conc> (instr, tail_instr), [exp | tail_arg])
    with
      (tail_instr, tail_arg) := <extract-instructions> t

  extract-instructions: [h | t] -> (tail_instr, [h | tail_arg])
    with
      (tail_instr, tail_arg) := <extract-instructions> t
      
  dnx-compile-exp(|p): var@RGR_AutoVar(_) -> ([], var)
  
  dnx-compile-exp(|p): DNX_Term(term) -> <debug(!"out: ")> <dnx-compile-term> <debug(!"in: ")>term
  
  dnx-compile-exp(|p): DNX_Cont(name) -> <dnx-primitive-cont-label> name
  
  
  // Just let the non-Dynamix arguments fall through
  // These are terms most often
  dnx-compile-exp(|p): e -> e
    where
      <not(string-starts-with(|"DNX_"))> <get-constructor> e
      
  dnx-compile-exp(|p): e -> <fail> <debug(!"[Dynamix] Cannot compile expression: ")> e
     
rules
  dnx-compile-term: DNXTerm_Int(val) -> val
  dnx-compile-term: DNXTerm_String(string) -> string
  dnx-compile-term: DNXTerm_Pat(name, args) -> <mkterm> (name, <map(dnx-compile-term)> args)
  dnx-compile-term: DNXTerm_List(elems) -> <map(dnx-compile-term)> elems
  dnx-compile-term: DNXTerm_ListTail(elems, tail) -> <concat> [<map(dnx-compile-term)> elems, <dnx-compile-term> tail]
  
  

  