module dnx-expression

imports
  signatures/Dynamix-sig
  
  codegen/dnx-common
  codegen/dnx-compile
  codegen/dnx-instruction
  codegen/fvm-primitive
  
  fvm-common

  
rules
  // Quotes need to skip this step, as their scoping is completely different
  dnx-compile-exp(|b, p, prop, blocks): DNX_Quote(Block(body)) -> ([], label)
    with
      quoted_binds_needed := <collect-all( (\ DNX_Splice(DNX_Var(var)) -> var\) )> body;
      quoted_binds := <map( (\ name -> ($[~_[name]], <lookup> (name, b)) \) )> quoted_binds_needed;
      (out, None()) := <dnx-compile-body(|prop, b)> (quoted_binds, p, body);
      label := <newname; dnx-primitive-autolabel> "l_";
      <hashtable-put(|label, out)> blocks
      
  dnx-compile-exp(|b, p, prop, blocks): exp -> out
    with
      bound_exp := <dnx-bind-args(|b)> exp;
      out := <dnx-compile-exp(|p, prop, blocks)> bound_exp
      
  dnx-bind-args(|binds): term -> <topdown(try(dnx-bind-args-(|binds)))> term
  dnx-bind-args-(|binds): DNXTerm_Var(name) -> <dnx-bind-args-(|binds)> DNX_Var(name)
  dnx-bind-args-(|binds): DNX_Splice(DNX_Var(name)) -> <lookup'> ($[~_[name]], binds)
  dnx-bind-args-(|binds): DNX_Var(name) -> <lookup'> (name, binds)
       
rules
  dnx-compile-exp(|p, prop, b): DNX_Call(c_name, c_param, c_args) -> (instr, out_exp)
    with
      s_name := <lookup-or-default(|c_name)> (c_name, p);
      s_param := <map((\ param -> <lookup-or-default(|param)> (param, p) \))> c_param;
      (arg_instrs, args_exp) := <extract-instructions> <map(dnx-compile-exp(|p, prop, b))> c_args;
      (out_instr, out_exp) := <dnx-call(|s_name, s_param, prop, b)> args_exp;
      instr := <conc> (arg_instrs, out_instr)
   
  lookup-or-default(|default): (name, map) -> res
    where
      res := <getfirst((\(key, val) -> val where <equal> (name, key)\))> map
  lookup-or-default(|default): _ -> default
  
  extract-instructions: [] -> ([], [])
  
  extract-instructions: [(instr, exp) | t] -> (<conc> (instr, tail_instr), [exp | tail_arg])
    with
      (tail_instr, tail_arg) := <extract-instructions> t

  extract-instructions: [h | t] -> (tail_instr, [h | tail_arg])
    with
      (tail_instr, tail_arg) := <extract-instructions> t
      
  dnx-compile-exp(|p, prop, b): var@RGR_AutoVar(_) -> ([], var)
  
//  dnx-compile-exp(|p, prop, b): DNX_Term(term) -> <debug(!"out: ")> <dnx-compile-term> <debug(!"in: ")>term
  dnx-compile-exp(|p, prop, b): DNX_Term(term) -> ([], <dnx-compile-term> term)
      
  dnx-compile-exp(|p, prop, b): DNX_Cont(name) -> ([], <dnx-primitive-cont-label> name)
  dnx-compile-exp(|p, prop, b): DNX_Link(name) -> ([], <dnx-primitive-link-label> name)
      
      
  // Just let the non-Dynamix arguments fall through
  // These are terms most often
  dnx-compile-exp(|p, prop, b): e -> e
    with
      <not(string-starts-with(|"DNX_"))> <get-constructor> e
      
  dnx-compile-exp(|p, prop, b): e -> <debug(!"[Dynamix] "); fail> $[Cannot compile expression: [<write-to-string> e]]
     
rules
  dnx-compile-term: DNXTerm_Int(val) -> val
  dnx-compile-term: DNXTerm_String(string) -> string
  dnx-compile-term: DNXTerm_Pat(name, args) -> <mkterm> (name, <map(dnx-compile-term)> args)
  dnx-compile-term: DNXTerm_List(elems) -> <map(dnx-compile-term)> elems
  dnx-compile-term: DNXTerm_Tuple(elems) -> <map(dnx-compile-term); ListToTuple> elems
  dnx-compile-term: DNXTerm_ListTail(elems, tail) -> <concat> [<map(dnx-compile-term)> elems, <dnx-compile-term> tail]
  dnx-compile-term: var@RGR_AutoVar(_) -> var
  dnx-compile-term: DNX_Cont(name) -> <dnx-primitive-cont-label> name
  dnx-compile-term: DNX_Link(name) -> <dnx-primitive-link-label> name
  
 
  dnx-compile-term: e -> e
  

  