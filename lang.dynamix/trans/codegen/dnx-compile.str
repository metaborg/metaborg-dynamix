module dnx-compile

imports
  signatures/Dynamix-sig
  codegen/dnx-common
  
  codegen/fvm-primitive
  codegen/dnx-match
  codegen/dnx-instruction
  
  fvm-util
  fvm-common

rules
  
  dnx-compile-to-fvm:
    (_, _, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"dnx.rgr")> path
    ; fname    := <base-filename; remove-extension> path
    ; (header, instr) := <dnx-compile> ast;
    result := <pp-framevm> <rgr-assign-registers> <rgr-from-flat> (header, [(<dnx-primitive-mk-label> "MAIN", FVM_AutoSize()) | instr])
    
  dnx-compile-to-flat-ast:
    (_, _, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"dnx.aterm")> path
    ; fname    := <base-filename; remove-extension> path
    ; result   := <dnx-compile> ast
    
rules
  dnx-compile: source_ast -> out
    with
      NormModule(header, imports, defs) := <import-term(src-gen/dynamix/spec.aterm)>;
      <map(dnx-store-def)> defs;
      (instr, None()) := <dnx-call(|"eval", [])> [source_ast];
      compiled_header := <dnx-primitive-mk-header> imports;
      out := (compiled_header, instr)
          
  dnx-store-def =
    ?NormDef(name, type, defs)
    ; rules( dnx-get-defs-by-name: name -> defs )
    
  dnx-call(|defname, param): args -> out
    where
      defs := <dnx-get-defs-by-name> defname
    with
      match := <getfirst(dnx-match-rule(|args, param)) <+ !None()> defs;
      bound_body := <dnx-compile-get-out(|defname, args)> match;
      out := <dnx-compile-body> bound_body
      
    // Primitive
  dnx-call(|primname, param): args -> out
    where
      [] := param
    with
      out := <dnx-primitive-call> (primname, args)
      
  dnx-compile-get-out(|defname, ast): Some(a) -> a
  dnx-compile-get-out(|defname, ast): None() -> MatchError(error)
    where
      ast' := ast; 
      error := <debug(!"[Dynamix] ")> (${Could not match the following arguments with the rule '{defname}':}, ast)
