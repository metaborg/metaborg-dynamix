module dnx-compile

imports
  signatures/Dynamix-sig
  codegen/dnx-common
  
  codegen/fvm-primitive
  codegen/dnx-primitive
  codegen/dnx-match
  codegen/dnx-instruction
    
rules
  dnx-compile: (source_ast, Some(dnx-module)) -> out
    with
      NormModule(name, header, defs) := dnx-module;
      <map(dnx-store-def)> defs;
      blocks := <new-hashtable>;
      properties := <new-hashtable>;
      DNX_Header(_, _, namespaces) := header;

      // This is not nice, but it works
      <hashtable-put(|"namespaces", namespaces)> properties;
      (instr, err) := <dnx-call(|"eval", [], properties, blocks)> [source_ast];
      tmp_labels := <hashtable-getlist; filter( (\ (key, val) -> (val, bound_val) where bound_key := <string-starts-with(|"tmp_lbl_"); string-replace(|"tmp_lbl_", "lbl_")> key; bound_val := <hashtable-get(|bound_key)> properties \) )> properties;
      compiled_header := <dnx-primitive-mk-header> header;
      blocks_instr := <hashtable-getlist; map((\ (label, body) -> [(label, <dnx-primitive-autosize>) | body] \)); concat> blocks;
      body2 := <conc> (instr, blocks_instr);
      body3 := <foldl(replace-tmp-labels)> (tmp_labels, body2); 
      out := <dnx-mk-final-output> (compiled_header, body3, err)
  
  dnx-compile: (_, None()) -> DNX_Error(error)
    where
      error := <debug(!"[Dynamix] ")> "No Dynamix specification loaded! Compiling failed"
  
  replace-tmp-labels: ((key, val), body) -> <topdown(try(?(key); !val))> body
  
  dnx-mk-final-output: (header, instr, None()) -> out
    where
      errors := <collect-all(?(MatchError(_)))> instr;
      // If there are errors, show them. Otherwise output (header, instr)
      out := <?(e, i); !e; length; ?(l); !(l, 0); ((gt; !e) <+ !(header, i))> (errors, instr)
      
  dnx-mk-final-output: (header, instr, err@MatchError(_)) -> [err]

rules          
  dnx-store-def =
    ?DefGroup(name, defs)
    ; rules( dnx-get-defs-by-name: name -> defs )
    
  dnx-call(|defname, param, properties, blocks): args -> out
    with
      out := <dnx-call-(|defname, param, properties, blocks); call-out-to-register> args
      
  // If a call returns an expression which is not a register, put it in a register
  call-out-to-register: e@(instr, None()) -> e
  call-out-to-register: e@(instr, exp) -> (<conc> (instr, a_instr), new_var) where <not(dnx-primitive-is-var); dnx-primitive-is-exp> exp
    with
      new_var := <newname; dnx-primitive-autovar> "exp";
      (a_instr, None()) := <dnx-primitive-assign> (new_var, exp)
  call-out-to-register: e -> e
  
  dnx-call-(|defname, param, properties, blocks): args -> out
    where
      defs := <dnx-get-defs-by-name> defname
    with
      match := <getfirst(dnx-match-rule(|args, param)) <+ !None()> defs;
      bound_body := <dnx-compile-get-out(|defname, args)> match;
      out := <dnx-compile-body(|properties, blocks)> bound_body
      
  // Primitive
  dnx-call-(|primname, param, properties, blocks): args -> out
    where
      [] := param
    with
      out := <dnx-primitive-call(|properties) <+ (!${Missing primitive implementation for {<write-to-string> primname}}; debug(!"[Dynamix] "); fail)> (primname, args)
        
  dnx-compile-get-out(|defname, ast): Some(a) -> a
  dnx-compile-get-out(|defname, ast): None() -> MatchError(error)
    where      
      rule_name_str := <write-to-string> defname;
      ast_str := <strip-annos; topdown(try(dnx-primitive-is-var; !Exp())); write-to-string> ast;
      ast_type_str := <map(((\ ast -> type  where 
      	a := <nabl2-get-ast-analysis> ast;
      	type := <nabl2-get-ast-type(|a)> ast\
      ); strip-annos; write-to-string) <+ !"_")> ast;
      error := <debug(!"[Dynamix] ")> ${Could not match the following arguments with the rule {rule_name_str}: {ast_str}:{ast_type_str}}
