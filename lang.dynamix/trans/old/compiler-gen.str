module compiler-gen

imports
  signatures/Dynamix-sig
  Stratego-Sugar-in-Stratego
  pp
  pp-stratego
  
rules
  
  generate-compiler:
    (_, _, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"dnx.str.aterm")> path
    ; fname    := <base-filename; remove-extension> path
    ; result   := <pp-stratego-to-string> <dnx-to-str(|fname)> ast
    
  generate-compiler-ast:
    (_, _, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"dnx.str.aterm")> path
    ; fname    := <base-filename; remove-extension> path
    ; result   := <dnx-to-str(|fname)> ast

  dnx-to-str(|fname) = fail
//
//  dnx-term-to-str: DNX_Term(None(), name, args) -> Op(name, <map(dnx-term-to-str)> args)
//  
//  dnx-to-str(|fname): DNX_Spec(rles) -> Module(fname, <concat> [[signatures, fvm_imports, dnx_imports, toplevel], compile-rules])
//    where
//      signatures  := Imports([Import("signatures/<YOUR_SIGNATURES>-sig")]);
//      dnx_imports := Imports([Import("dynamix/dnx-common"), Import("dynamix/dnx-stdlib"), Import("dynamix/dnx-templates")]);
//      fvm_imports := Imports([Import("signatures/fvm-roger-sig"), Import("signatures/fvm-common-sig"), Import("signatures/framevm-sig"), Import("fvm-util")]);
//
//      namespaces := ["Var"];
//      header := |[ [FVM_InitSize("1"), FVM_ContAlias(FVM_Cont("n"), "1"), FVM_LinkAlias(FVM_Link("Q"), "1")] ]|;
//      
//      toplevel := Rules([|[ 
//        compile-to-fvm: ast -> ast'
//	      with
//	        <dnx-init-maps> ast;
//	        <dnx-set-slot-namespaces> ~namespaces;
//	        header := ~header
//	      with
//	        flat_ast := <compile-init> ast;
//	        ast':= <rgr-from-flat; dnx-allocate-registers; dnx-validate> (FVM_Header(header), flat_ast)	    
//      ]|]);
//      
//      compile-rules := <map(dnx-rules-to-str)> rles
//      
//  dnx-rules-to-str: DNX_Rules(rls) -> Rules(<map(dnx-rule-to-str)> rls)
//  
//  dnx-rule-to-str: DNX_Rule(name, term_in, _, _, _, out, body) -> |[
//    rule_name: ~term_in -> <flatten-list> []
//      with
//        ~str_body
//  ]| where
//    rule_name := $[compile-[name]];
//    str_body := []
//      
//  
//  
//  
//  