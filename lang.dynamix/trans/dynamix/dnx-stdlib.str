module dnx-stdlib

imports
  nabl2/api
  dynamix/dnx-common
  
imports
  signatures/fvm-roger-sig
  signatures/fvm-common-sig
      
// Dynamix library functions
rules // Templating
    dnx-apply-template(|args): (template, labels, vars) -> templated
      with
	    labels_map := <zip>(labels, <map(newname)> labels);
	    vars_map := <zip>(vars, <map((\ _ -> <newname> "t_" \))> vars);
	    argument_map := <flatten-list> <map-with-index(dnx-template-arg-create-map)> args;
	    templated := <flatten-list> <foldl(dnx-fold-template)> (<concat> [labels_map, vars_map, argument_map], template)
   
    dnx-fold-template: ((from, to), ast) -> <bottomup(try(dnx-fold-template-replace(|from, to)))> ast
    dnx-fold-template-replace(|from, to): from -> to
         
    dnx-template-arg-create-map: (idx, arg) -> [(DNX_TemplateVar(idx'), arg), (DNX_TemplateVarInit(idx'), init), (DNX_TemplateVarLast(idx'), last)] where <is-list> arg
      with 
        idx':= <dec> idx;
        (init, last) := <split-init-last> arg
      
    dnx-template-arg-create-map: (idx, arg) -> (DNX_TemplateVarLast(idx'), arg) 
      with 
        idx':= <dec> idx
    
rules // Register allocation
    dnx-allocate-registers: RGR_Program(h, p, blocks) -> RGR_Program(h, p, <dnx-allocate-shared-wildcards(|h)> blocks)
    
    dnx-allocate-local-wildcards: (RGR_Block(lbl, s, r, body, jump), binds) -> RGR_Block(lbl, s, r', body', jump')
      where
        ([r'], binds1) := <dnx-allocate-local-wildcards-instr> ([r], binds);
        (body', binds2) := <dnx-allocate-local-wildcards-instr> (body, binds1);
        ([jump'], _) := <dnx-allocate-local-wildcards-instr> ([jump], binds2)
   
    dnx-allocate-shared-wildcards(|header): blocks -> blocks'
      with
        blocks_map := <map((\b@RGR_Block(FVM_Label(lbl), _, _, _, _) -> (lbl, b)\))> blocks;
        FVM_Header(items) := header;
        initial_block := <getfirst(?(FVM_InitBlock(lbl)); !lbl) +> !"MAIN"> items;
        (blocks_map', _, _) := <dnx-allocate-shared-wildcards-recurse> (initial_block, (blocks_map, [], []));
        blocks' := <map((\(_, block) -> block\))> blocks_map'
    
    dnx-allocate-shared-wildcards-recurse: (block, (map, discovered, binds)) -> (map4, discovered4, binds4)
      where
        <not(elem)> (block, discovered)
      with
        discovered2 := [block | discovered];
        RGR_Block(lbl, s, r, body, jump) := <lookup'> (block, map);
        ([r'], binds1) := <dnx-allocate-shared-wildcards-instr> ([r], binds);
        (body', binds2) := <dnx-allocate-shared-wildcards-instr> (body, binds1);
        ([jump'], binds3) := <dnx-allocate-shared-wildcards-instr> ([jump], binds2);
        block' := RGR_Block(lbl, s, r', body',jump');
        map2 := <list-some(dnx-map-update(|block, <dnx-allocate-local-wildcards> (block', binds3)))> map;
        (jump_lbl, cf_lbl) := <collect-all(dnx-is-jump-lbl <+ dnx-is-cf-lbl); dnx-split-jump-cf-lbls> block';
        (map3, discovered3, binds4) := <foldl(dnx-allocate-shared-wildcards-recurse)> (jump_lbl, (map2, discovered2, binds3));
        (map4, discovered4, _) := <foldl(dnx-allocate-shared-wildcards-recurse)> (cf_lbl, (map3, discovered3, []))
    
    dnx-allocate-shared-wildcards-recurse: (_, acc@(_, _, _)) -> acc // Block already discovered

    dnx-map-update(|block, new_val): (block, _) -> (block, new_val)
      
    dnx-split-jump-cf-lbls: list -> (<flatten-list><filter(dnx-is-jump-lbl-f)> list, <flatten-list><filter(dnx-is-cf-lbl-f)> list)
    
    
    dnx-is-cf-lbl= ?(RGR_ContNew(_, _, _)) <+ 
                   ?(RGR_Call(_, _, _))    <+ 
                   ?(RGR_TailCall(_, _))   <+ 
                   ?(RGR_ClosNew(_, _, _)) <+ 
                   ?(RGR_Try(_, _, _, _, _))
                   
    dnx-is-jump-lbl= ?(RGR_Yield(_,_)) <+ 
                     ?(RGR_JumpZ(_,_,_)) <+ 
                     ?(RGR_Jump(_)) <+ 
                     ?(RGR_Call(_, _, _)) <+ 
                     ?(RGR_Call(_, _)) <+ 
                     ?(RGR_ContCall(_, _)) <+ 
                     ?(RGR_Try(_, _, _, _, _)) <+ 
                     ?(RGR_Try(_, _, _)) <+ 
                     ?(RGR_ScopeExit(_, _)) <+ 
                     ?(RGR_ScopeNew(_,_,_))
    
    
    dnx-is-cf-lbl-f: RGR_ContNew(_, FVM_Label(lbl), _) -> lbl
    dnx-is-cf-lbl-f: RGR_Call(_, FVM_Label(lbl), _) -> lbl
    dnx-is-cf-lbl-f: RGR_TailCall(_, FVM_Label(lbl)) -> lbl
    dnx-is-cf-lbl-f: RGR_ClosNew(_, FVM_Label(lbl), _) -> lbl
    dnx-is-cf-lbl-f: RGR_Try(_, FVM_Label(lbl1), _, FVM_Label(lbl2), _) -> [lbl1, lbl2]
    
    dnx-is-jump-lbl-f: RGR_Yield(_,FVM_Label(lbl)) -> lbl
    dnx-is-jump-lbl-f: RGR_JumpZ(_,FVM_Label(lbl1),FVM_Label(lbl2)) -> [lbl1, lbl2]
    dnx-is-jump-lbl-f: RGR_Jump(FVM_Label(lbl)) -> lbl
    dnx-is-jump-lbl-f: RGR_Call(_, _, FVM_Label(lbl)) -> lbl
    dnx-is-jump-lbl-f: RGR_Call(_, FVM_Label(lbl)) -> lbl
    dnx-is-jump-lbl-f: RGR_ContCall(_, FVM_Label(lbl)) -> lbl
    dnx-is-jump-lbl-f: RGR_Try(_, _, _, _, FVM_Label(lbl)) -> lbl
    dnx-is-jump-lbl-f: RGR_Try(_, _, FVM_Label(lbl)) -> lbl
    dnx-is-jump-lbl-f: RGR_ScopeExit(_, FVM_Label(lbl)) -> lbl
    dnx-is-jump-lbl-f: RGR_ScopeNew(_,_,FVM_Label(lbl)) -> lbl
    
rules // Actual wildcard application  
    dnx-init-static-maps: e -> e
      with
        <new-static> ("func-map", <new-hashtable>)
      
    dnx-allocate-local-wildcards-instr: (instrs, binds) -> <foldl(dnx-allocate-local-wildcards-instr-fold)> (instrs, ([], binds))
    
    dnx-allocate-local-wildcards-instr-fold: (Some(RGR_OnReturn(vars, val)), (instrs, binds)) -> (<flatten-list> [instrs, Some(RGR_OnReturn(vars', val))], binds')
      where
        local_vars := <map(\DNX_AssignVar(var) -> var\)> vars
      with
        binds':= <flatten-list; make-set> [binds, local_vars];
        vars' := <map(dnx-apply-local-binds(|binds'); (\RGR_Ref(ref) -> ref\))> vars
        
    dnx-allocate-local-wildcards-instr-fold: (RGR_Assign(var@DNX_AssignVar(var_wld), val), (instrs, binds)) -> (<flatten-list> [instrs, instr'], binds')
      with
        val':= <topdown(try(dnx-apply-local-binds(|binds)))> val;
        binds':= <flatten-list; make-set> [binds, var_wld];
        RGR_Ref(var') := <dnx-apply-local-binds(|binds')> var;
        instr' := RGR_Assign(var', val')
  
    dnx-allocate-local-wildcards-instr-fold: (instr, (instrs, binds)) -> (<flatten-list> [instrs, instr'], binds) where instr' := <topdown(try(dnx-apply-local-binds(|binds)))> instr

    dnx-apply-local-binds(|binds): DNX_AssignVar(var) -> <dnx-lookup-assign> (var, binds)
    
    
    dnx-allocate-shared-wildcards-instr: (instrs, binds) -> <foldl(dnx-allocate-shared-wildcards-instr-fold)> (instrs, ([], binds))
    
    dnx-allocate-shared-wildcards-instr-fold: (Some(RGR_OnReturn(vars, val)), (instrs, binds)) -> (<flatten-list> [instrs, Some(RGR_OnReturn(vars', val))], binds')
      where
        shared_vars := <map(\DNX_SharedAssignVar(var) -> var\)> vars
      with
        binds':= <flatten-list; make-set> [binds, shared_vars];
        vars' := <map(dnx-apply-shared-binds(|binds'); (\RGR_Ref(ref) -> ref\))> vars
      
    dnx-allocate-shared-wildcards-instr-fold: (RGR_Assign(var@DNX_SharedAssignVar(var_wld), val), (instrs, binds)) -> (<flatten-list> [instrs, instr'], binds')
      with
        val':= <topdown(try(dnx-apply-shared-binds(|binds)))> val;
        binds':= <flatten-list; make-set> [binds, var_wld];
        RGR_Ref(var') := <dnx-apply-shared-binds(|binds')> var;
        instr' := RGR_Assign(var', val')
  
    dnx-allocate-shared-wildcards-instr-fold: (instr, (instrs, binds)) -> (<flatten-list> [instrs, instr'], binds) where instr' := <topdown(try(dnx-apply-shared-binds(|binds)))> instr

    dnx-apply-shared-binds(|binds): DNX_SharedAssignVar(var) -> <dnx-lookup-assign> (var, binds)
    
    dnx-lookup-assign: (name, binds) -> RGR_Ref($[r[<dec><get-index> (name, binds)]])
   

rules // Helper functions 
    dnx-sequence(s): exps -> <flatten-list; map(s); concat> exps
    dnx-next-local-assign-var:  _ -> DNX_AssignVar(<newname> "l_")
    dnx-next-shared-assign-var: _ -> DNX_SharedAssignVar(<newname> "s_")
    
    dnx-execute-in-scope(|lbl, size): term -> <flatten-list> [RGR_Stmt(RGR_ScopeNew(RGR_New(<int-to-string> size), FVM_Link(lbl))), term, RGR_Stmt(RGR_ScopeExit(FVM_Path([FVM_Link(lbl)])))]
    
    dnx-assign-sequence(compile-s): exps -> <dnx-exp-sequence-with(compile-s, \c -> RGR_Assign(var, c)\)> with var := <dnx-next-shared-assign-var>
    dnx-exp-sequence-with(compile-s, s): exps -> <flatten-list> [init_instrs, last_instr_exp]
      with
        (init, last) := <split-init-last> exps;
	    (init_instr, init_exp) := <unzip> <map(compile-s; split-init-last)> init;	
	    init_instrs := <zip; map((\(i1, i2) -> <flatten-list> [i1, i2]\)); flatten-list> (init_instr, <map(s)> init_exp);
	    last_instr_exp := <compile-s> last
        
    dnx-resolve-name(|namespace): name -> FVM_Path(path)
      with
        a       := <nabl2-get-ast-analysis> name;
        ref-occ := <nabl2-mk-occurrence(|namespace)> name;
        path    := <dnx-resolve-name-path(|namespace, name,  a)> ref-occ
        
    dnx-resolve-name-path(|namespace, name, a): ref-occ -> fvm_path 
      where
        (dec-occ, path) := <nabl2-get-resolved-name(|a)> ref-occ
      with
        (path_body, path_end) := <split-init-last> path;
        fvm_path     := <concat>[<map(dnx-from-nabl2-path)> path_body, [<dnx-resolve-name-slot(|namespace, name, a)> dec-occ]]
    
    dnx-resolve-name-path(|namespace, name, a): ref-occ -> fvm_path 
      where
        fvm_path := [<dnx-resolve-name-slot(|namespace, name, a)> ref-occ]
        
    dnx-resolve-name-slot(|namespace, name, a): occ -> FVM_Slot(<int-to-string> idx)
      with 
        TermIndex(termfile, termidx) := <nabl2-get-occurrence-index> occ;
        scope := <nabl2-get-decl-scope(|a)> occ;
        occs := <nabl2-get-scope-decls(|a); filter(?(Occurrence(Namespace(namespace), _, _)))> scope;
		idx := <find-index(dnx-is-occurrence-with-name(|name))> occs
    
    dnx-is-occurrence-with-name(|req-name): occ@Occurrence(_, name, _) -> occ where <equal> (<strip-annos> req-name, <strip-annos> name)
    
    dnx-from-nabl2-path: E(scope, lbl) -> FVM_Link(<get-constructor> lbl)
    
    dnx-store-in-frame(c|frame): vals -> <concat> vals_instr
      with
         vals_instr := <map-with-index(dnx-store-in-frame-(c|frame))> vals
         
    dnx-store-in-frame-(c|frame): (idx, term) -> <flatten-list> [instr, assign] 
	  with 
	    (instr, val) := <split-init-last> <c> term;
	    assign := RGR_Stmt(RGR_Set(frame, FVM_Path([FVM_Slot(<int-to-string> <dec> idx)]), val))

rules // Validation rules
    dnx-validate = dnx-check-unbound-vars
    
    is-dnx-template= ?(DNX_AssignVar(_)) <+ ?(DNX_SharedAssignVar(_)) <+ ?(DNX_TemplateVar(_)) <+ ?(DNX_TemplateVarInit(_)) <+ ?(DNX_TemplateVarLast(_))
    dnx-check-unbound-vars: a -> a where collect-all(is-dnx-template); (?([]) <+ (debug(!"The output contains unbound variables (this could imply unreachable code):\n"); fail))
    dnx-check-unbound-vars = debug; fail