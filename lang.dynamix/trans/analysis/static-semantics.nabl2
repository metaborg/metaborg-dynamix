module analysis/static-semantics

imports

  signatures/-
  analysis/definitions
  analysis/common

rules // Init rule
  init ^ (s) := new s,
    TermT()  <sub! TermOrExpT(),
  	ExpT()   <sub! TermOrExpT(),
  	ReturnT() <sub! InstrT().
  
rules // Module
  // First check if the signature is correct and in the right file
  // After that do the actual module
  [[mod@Module(name@"dynamic-semantics", _, _, _, _, DNX_Header([], _, _)) ^(s)]] :=
    false | error $[Missing 'link-labels' in signature] @name,
    module[[mod ^(s)]].

  [[mod@Module(name@"dynamic-semantics", _, _, _, _, DNX_Header(_, [], _)) ^(s)]] :=
    false | error $[Missing 'continuations' in signature] @name,
    module[[mod ^(s)]].

  [[mod@Module(name@"dynamic-semantics", _, _, _, _, DNX_Header(_, _, [])) ^(s)]] :=
    false | error $[Missing 'namespaces' in signature] @name,
    module[[mod ^(s)]].

  [[mod@Module("dynamic-semantics", _, _, _, _, _) ^(s)]] :=
    module[[mod ^(s)]].

  [[mod@Module(name, _, _, _, _, DNX_Header([_|_], [_|_], [_|_])) ^(s)]] :=
    false | error $[Signature only allowed in the main file (for now) ] @name,
    module[[mod ^(s)]].

  [[mod@Module(_, _, _, _, _, _) ^(s)]] :=
    module[[mod ^(s)]].
  
  module[[Module(name, imports, prim_names, Defs(types), Defs(defs), header) ^(s)]] :=
    new module, module ---> s,
    Module{name} <- s,
    Module{name} ===> module,
    distinct/name D(s)/Module | error $[Multiple modules with name [name]] @NAMES,
    
    Map1(primNames) [[prim_names ^(s)]],
    header          [[header ^(s)]],
    Map1(typeDecl)  [[types ^(s)]],
//    If we ever fix the issue with imports, we should use this line instead:
//    Map1(typeDecl)  [[types ^(module)]],
    Map1(import)    [[imports ^(module)]],

    new declarations, declarations ---> module,
    Map1(def) [[defs ^(declarations)]].
    
rules  // Header
  header [[DNX_Header(links, continuations, namespaces) ^(s)]] := 
    Map1(initLinks) [[ links ^(s)]],
    Map1(initConts) [[ continuations ^(s)]].
    
  initLinks [[(idx, lbl) ^(s) ]] :=
    Link{lbl} <- s,
    Link{lbl}: TermT(),
    Link{lbl}.index := idx.
    
  initConts [[(0, lbl) ^(s) ]] :=
    false | note $[Return of the initial control frame] @lbl,
    Cont{lbl} <- s,
    Cont{lbl}: TermT(),
    Cont{lbl}.index := idx.
    
  initConts [[(1, lbl) ^(s) ]] :=
    false | note $[Exeption handler of the initial control frame] @lbl,
    Cont{lbl} <- s,
    Cont{lbl}: TermT(),
    Cont{lbl}.index := idx.
    
  initConts [[(idx, lbl) ^(s) ]] :=
    Cont{lbl} <- s,
    Cont{lbl}: TermT(),
    Cont{lbl}.index := idx.
    
rules  // Imports
  import [[name ^(s)]] :=
    Module{name} -> s,
    Module{name} |-> d | error $[Cannot resolve module '[name]'] @name.
//    We dont do the actual import as that results in terribly slow analysis times
//    Sometimes they just crash with out of memory errors
//    We should probably think of a fix for this...
//    (Unwanted behaviour can be observed with the Tiger project)
//    Module{name} <=== s.

rules // Type declarations
  typeDecl [[TypeDef(name@"eval", paramType, args, ret) ^(s) ]] :=
    Def{name} <- s,
    type [[ret ^(s) : retty]],
    Map1T(type) [[args ^(s) : argty]],
    Map1T(paramTypeDecl) [[paramType ^(s) : paramty]],
    
    Def{name}:DefT(paramty, argty, retty) | error $[Invalid type for rule eval, should be 'ast -> instr'] @name,
    Def{name}:DefT([], [TermT()], InstrT()),
    distinct/name D(s)/Def | error $[Multiple type signatures for rule [name]] @NAMES.
    
  typeDecl [[TypeDef(name, paramType, args, ret) ^(s) ]] :=
    Def{name} <- s,
    type [[ret ^(s) : retty]],
    Map1T(type) [[args ^(s) : argty]],
    Map1T(paramTypeDecl) [[paramType ^(s) : paramty]],
    Def{name}:DefT(paramty, argty, retty)!,
    distinct/name D(s)/Def | error $[Multiple type signatures for rule [name]] @NAMES.
  
  paramTypeDecl [[ParamType(args, ret) ^(s) : ParamT(argty, retty)]] :=
    type [[ret ^(s) : retty]],
    Map1T(type) [[args ^(s) : argty]].
      
rules // Definitions   
  def[[Def(name, param, args, Block(instrs)) ^(s)]] :=
    Def{name} -> s,
    Def{name} |-> d | error $[No type signature for rule [name]],
    d:DefT(dparamty, dtys, drty),
    new def_q_s, def_q_s ---> s,
    Map1T(defParam) [[param ^(def_q_s) : paramty]],
    Map1T(parterm) [[args ^(def_q_s) : tys]],
    
    new def_s,   def_s   ---> def_q_s,
    Fold1TC(instr) [[instrs ^(def_s, def_q_s) : rty]],
    dtys == tys,
    dparamty == paramty,
    rty <sub? drty | error $[Wrong return type. Expected [drty], but got [rty]] @name.
  
  defParam [[name ^(s) : ParamT(argty, rty) ]] :=
    Def{name} <- s,
    Def{name}:DefT([], argty, rty)!.
    
rules // Basic types
  type[[ Term()   ^(s) : TermT()   ]].
  type[[ Code()   ^(s) : CodeT()   ]].
  type[[ Exp()    ^(s) : ExpT()    ]].
  type[[ Instr()  ^(s) : InstrT()  ]].
  type[[ Return() ^(s) : ReturnT() ]].
  
rules // Parameter terms
  parterm[[DNXTerm_Var(name) ^(s) : ty]] :=
    Var{name} <- s,
    Var{name}:ty!,
    QVar{name} <- s,
    QVar{name}:ty!.
    
  parterm[[DNXTerm_List(elems) ^(s) : TermT()]] :=
    partermMap [[elems ^(s) : TermT()]].
    
  parterm[[DNXTerm_Tuple(elems) ^(s) : TermT()]] :=
    partermMap [[elems ^(s) : TermT()]].
    
  parterm[[DNXTerm_At(name, pattern) ^(s) : TermT()]] :=
    Var{name} <- s,
    Var{name}:TermT()!,
    parterm [[pattern ^(s) : TermT()]].
    
  parterm[[DNXTerm_Type(pattern, type) ^(s) : TermT()]] :=
    parterm [[pattern ^(s) : TermT()]].
    
  parterm[[DNXTerm_ListTail(elems, tail) ^(s) : TermT()]] :=
    partermMap [[elems ^(s) : TermT()]],
    parterm [[tail ^(s) : TermT()]].
    
  parterm[[DNXTerm_ListLast(init, last) ^(s) : TermT()]] :=
    partermMap [[last ^(s) : TermT()]],
    parterm [[init ^(s) : TermT()]].
    
  parterm[[DNXTerm_Pat(name, args) ^(s) : TermT()]] :=
    partermMap [[args ^(s) : TermT()]].
    
  parterm[[DNXTerm_Int(_) ^(s) : TermT()]].
    
  parterm[[DNXTerm_String(_) ^(s) : TermT()]].
  parterm[[DNX_Link(_) ^(s) : TermT()]].
  parterm[[DNX_Cont(_) ^(s) : TermT()]].
  
  partermMap [[ [] ^(s) : ty ]].
  partermMap [[ [h|t] ^(s) : ty ]] :=
    parterm [[h ^(s) : ty]], partermMap [[t ^(s) : ty ]].
  
rules // Expression terms
  expterm[[DNXTerm_Var(name) ^(s) : ty]] :=
    Var{name} -> s,
    Var{name} |-> d | error $[Variable [name] not defined] @name,
    d:ty!.
    
  expterm[[DNXTerm_List(elems) ^(s) : TermT()]] :=
    exptermMap [[elems ^(s) : TermT()]].
    
  expterm[[DNXTerm_Tuple(elems) ^(s) : TermT()]] :=
    exptermMap [[elems ^(s) : TermT()]].
    
  expterm[[DNXTerm_ListTail(elems, tail) ^(s) : TermT()]] :=
    exptermMap [[elems ^(s) : TermT()]],
    expterm [[tail ^(s) : TermT()]].
    
  expterm[[DNXTerm_ListLast(init, last) ^(s) : TermT()]] :=
    exptermMap [[last ^(s) : TermT()]],
    expterm [[init ^(s) : TermT()]].
    
  expterm[[DNXTerm_Pat(name, args) ^(s) : TermT()]] :=
    exptermMap [[args ^(s) : TermT()]].
    
  expterm[[term@DNXTerm_At(name, pattern) ^(s) : TermT()]] :=
    false | error $[Unsupported operation] @ term.
    
  expterm[[term@DNXTerm_Type(pattern, type) ^(s) : TermT()]] :=
    false | error $[Unsupported operation] @ term.
    
  expterm[[DNXTerm_Int(_) ^(s) : TermT()]].
    
  expterm[[DNXTerm_String(_) ^(s) : TermT()]].
  expterm[[DNX_Link(_) ^(s) : TermT()]].
  expterm[[DNX_Cont(_) ^(s) : TermT()]].
  
  exptermMap [[ [] ^(s) : ty ]].
  exptermMap [[ [h|t] ^(s) : ty ]] :=
    expterm [[h ^(s) : ty]], exptermMap [[t ^(s) : ty ]].
  
    

rules // Instructions
  Fold1TC(X) [[ [DNX_Return(arg)] ^(s, p) : ExpT() ]] :=
    rty == ExpT() | error $[A value of type [rty] cannot be returned by a definition],
    exp [[arg ^(s, p) : rty]].
    
  Fold1TC(X) [[ [DNX_Return(arg) | tail] ^(s, p) : ExpT() ]] :=
    rty == ExpT() | error $[A value of type [rty] cannot be returned by a definition],
    exp [[arg ^(s, p) : rty]],
    Fold1TC(instr) [[tail ^(s, p) : _]],
    false | error $[Dead code] @tail.
    
  Fold1TC(X) [[ [h] ^(s, p) : ty ]] :=
    X[[ h ^(s, _, p) : ty]].
    
  Fold1TC(X) [[ [h | t] ^(s, p) : ty ]] :=
    X[[ h ^(s, s', p) : _ ]],
    Fold1TC(X)[[ t ^(s', p) : ty ]].
  
  
  instr [[ DNX_Bind(name, exp) ^(s, def_s, p) : InstrT() ]] :=
    exp [[exp ^(s, p) : expty]],
    new def_s,
    def_s ---> s,
    Var{name} <- def_s,
    Var{name}:expty!.
    
  instr [[ DNX_Exp(exp) ^(s, s', p) : defrty ]] :=
    s == s', 
    exp[[exp ^(s, p) : defrty]].
    
  instr [[ DNX_Label(_) ^(s, s', _) : InstrT() ]] :=
    s == s'.
    
rules // Expressions  
  exp [[DNX_Link(lbl) ^(s, _) : ty ]] :=
    Link{lbl} -> s,
    Link{lbl} |-> d | error $[Link with label [lbl] is not defined],
    d : ty.
  
  exp [[DNX_Cont(lbl) ^(s, _) : ty ]] :=
    Cont{lbl} -> s,
    Cont{lbl} |-> d | error $[Continuation with label [lbl] is not defined],
    d : ty.
    
  exp [[DNX_Label(_) ^(s, _) : CodeT() ]]. // TODO: Check if these resolve in the current rule
  
  exp [[DNX_Var(name) ^(s, _) : ty ]] :=
    Var{name} -> s,
    Var{name} |-> d | error $[Variable [name] not declared] @name,
    d:ty.
    
  exp [[DNX_Call(name, param, args) ^(s, p) : rty ]] :=
    Def{name} -> s,
    Def{name} |-> d | error $[Rule [name] not declared] @name,
    d:DefT(dparamty, defargtys, defrty)!,
    Map2T(exp) [[args ^(s, p) : argtys]],
    Map1T(expParam) [[param ^(s) : paramty]],
    rty == defrty,
    paramty == dparamty,
    argtys <sub? defargtys | error $[Wrong argument type. Expected [defargtys], found [argtys]].
     
  exp [[DNX_Quote(Block(instrs)) ^(s, p) : CodeT()]] :=
    new quote_s, quote_s ---> p,
    qty <sub? InstrT() | error $[Found [qty], expected [InstrT()]],
    Fold1TC(instr) [[instrs ^(quote_s, quote_s) : qty]].
    
  exp [[DNX_Splice(DNX_Var(name)) ^(s, _) : ty ]] :=
    QVar{name} -> s,
    QVar{name} |-> d | error $[Variable [name] not declared] @name,
    d:sty,
    ty == sty.
    
  exp [[DNX_Term(term) ^(s, _) : ty ]] := expterm [[term ^(s) : ty]].
  
  expParam [[name ^(s) : ParamT(argty, retty) ]] :=
    Def{name} -> s,
    Def{name} |-> d | error $[Rule [name] not defined],
    d:DefT(dparamty, dargty, dretty),
    dparamty == [] | error $[Nesting parameterized rules is not allowed],
    argty == dargty, retty == dretty.
  
  
  