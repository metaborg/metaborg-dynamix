module analysis

imports
  nabl2/runtime/analysis/constraint-compat
  nabl2/api
  nabl2/runtime

  analysis/static-semantics
  signatures/Dynamix-sig
  codegen/dnx-common
  
rules
  desugar = collect-def-types; collect-prim-names; desugar-all; build-header
  editor-analyze = nabl2-analyze(desugar)

  desugar-all = topdown(try(desugar-term))
  
rules
  // Prints the abstract syntax ATerm of a selection.
  debug-show-aterm: (selected, _, _, path, project-path) -> (filename, result)
    with filename := <guarantee-extension(|"aterm")> path
       ; result   := selected
  
  // Prints the desugared syntax ATerm.
  debug-show-desugared-aterm: (_, _, ast, path, project-path) -> (filename, result)
    with filename := <guarantee-extension(|"desuagered.aterm")> path
       ; result   := <desugar> ast
       
  // Prints the analyzed annotated abstract syntax ATerm of a selection.
  debug-show-analyzed: (selected, _, _, path, project-path) -> (filename, result)
    with filename := <guarantee-extension(|"analyzed.aterm")> path
       ; result   := selected

rules
  // Label expressions are just labels
  desugar-term: DNX_LabelExp(lbl) -> DNX_Label(lbl)
  
  // Desugar the parameters of Definitions to be a (potentially empty) list  
  desugar-term: Def(name, None(), args, body) -> Def(name, [], args, body)
  desugar-term: Def(name, Some(Param(params)), args, body) -> Def(name, params, args, body)
  
  // Desugar parameters of calls to lists
  desugar-term: DNX_Call(name, None(), args) -> DNX_Call(name, [], args)
  desugar-term: DNX_Call(name, Some(Param(params)), args) -> DNX_Call(name, params, args)
  
  // Desugar primitive calls to normal calls
  desugar-term: DNX_CallPrim(name, param, args) -> <desugar-term> DNX_Call(name, param, args)
  
  // Fix the quotation and escaping of strings
  desugar-term: DNXTerm_String(string) -> DNXTerm_String(<unquote(id); string-replace(|"\\\\", "\\")> string)
  
  // Desugar parameters of type signatures to lists
  desugar-term: TypeDef(name, None(), argsty, retty) -> TypeDef(name, [], argsty, retty)
  desugar-term: TypeDef(name, Some(ParamTypeList(params)), argsty, retty) -> TypeDef(name, params, argsty, retty)
  
  // Split the definition types and implementations
  collect-def-types: Module(name, definitions) -> Module(name, imports, [], Defs(type_decls), Defs(def_decls), header)
    where
      (imports, header, defs) := <split-list3(?Imports(_), ?Header(_), ?Defs(_))> definitions;
      all_defs := <mapconcat((\ Defs(d) -> d \))> defs;
      def_decls  := <filter(?Def(_, _, _, _))> all_defs;
      type_decls := <filter(?TypeDef(_, _, _, _))> all_defs
  
  // Collect the names of primitive operations
  // For modules other than the main module, this returns an empty list
  collect-prim-names: Module(name@"dynamic-semantics", imports, _, types, defs, candl) -> Module(name, imports, prim_names, types, defs, candl)
    where
      prim_names := [
      		"jump", "empty", "push", "pop", "print", "printc", "jumpz", 
      		"callCF", "returnCF", "curCF", "newCF", "getCF", "setCF", "unpackCF", 
      		"int", "char", 
      		"ineg", "iadd", "imul", "isub", "idiv", "imod", "ieq", "ilt", "igt", "ior", "iand", "ixor", 
      		"is-int", "is-frame", "is-closure", "is-continuation", 
      		"mk-closure", "closure-to-CF", 
      		"new", "size", "link", "set", "mkcur", "cur", "get", "is-empty", 
      		"resolve", "resolve-label", "resolve-scope", 
      		"continue", "length", "zip-with-index", 
      		"associate-index", "associate-label"
      ]
      
  collect-prim-names: Module(name, imports, _, types, defs, candl) -> Module(name, imports, [], types, defs, candl)
  
  // Build the header of a module by extracting all relevant header information from the AST
  build-header: Module(name, imports, primitives, types, defs, header_elems) -> Module(name, imports', primitives, types, defs, header')
    where
      headers := <mapconcat(?Header(a); !a)> header_elems;
      (links, continuations, namespaces) := <split-list3(?Links(_), ?Continuations(_), ?Namespaces(_))> headers;
      imports'       := <mapconcat(?Imports(i); !i); map( (\ Import(i) -> i \) )> imports;
      links'         := <mapconcat(?Links(l); !l);         map-with-index( (\ (idx, LinkAlias(l))         -> <map( (\e -> (<dec>idx, e) \) )> l \) ); concat> links;
      continuations' := <mapconcat(?Continuations(c); !c); map-with-index( (\ (idx, ContinuationAlias(c)) -> <map( (\e -> (<dec>idx, e) \) )> c \) ); concat> continuations;
      namespaces'    := <mapconcat(?Namespaces(n); !n);    map( (\ NameSpace(ns) -> ns \) )> namespaces;
      header' :=  DNX_Header(links', continuations', namespaces')
    
      
      
  
